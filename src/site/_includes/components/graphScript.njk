<script>
    // Graph Color Configuration - Uses CSS variables for consistency with theme
    const GRAPH_CONFIG = {
        // Choose base color source:
        colorSource: 'graph-main',  // Options: 'text-normal', 'text-accent', 'custom', 'graph-main'
        
        // Custom color (only used if colorSource is 'custom'):
        customColor: '#44CF6E',
        
        // Opacity levels for different states
        fadedOpacity: 0.05,     // Much more transparent for unconnected nodes
        connectedOpacity: 1.0,  // Full opacity for connected nodes (clear contrast)
    };

    // Simple approach - use CSS variables like main branch but with enhanced contrast
    const GRAPH_COLORS = {
        // Nodes
        active: getCssVar("--graph-main"),              // Hovered nodes - green from theme
        connected: getCssVar("--graph-main"),           // Connected nodes - same green
        faded: 'rgba(68, 207, 110, 0.08)',             // Unconnected nodes - very faded green
        current: getCssVar("--graph-main"),             // Current page indicator
        
        // Edges/Links  
        edgeActive: '#147C83',                          // Active edges - teal color
        edgeConnected: '#147C83',                       // Connected edges - same teal
        edgeFaded: 'rgba(20, 124, 131, 0.08)'          // Faded edges - very transparent teal
    };

    async function fetchGraphData() {
        const graphData = await fetch('/graph.json').then(res => res.json());
        const fullGraphData  = filterFullGraphData(graphData);
        return {graphData, fullGraphData}
    }

    function getNextLevelNeighbours(existing, remaining) {
        const keys = Object.values(existing).map((n) => n.neighbors).flat();
        const n_remaining = Object.keys(remaining).reduce((acc, key) => {
                if (keys.indexOf(key) != -1) {
                    if (!remaining[key].hide) {
                        existing[key] = remaining[key];
                    }
                } else {
                    acc[key] = remaining[key];
                }
                return acc;
            }, {});
        return existing, n_remaining;
    }

    function filterLocalGraphData(graphData, depth) {
        if (graphData == null) {
            return null;
        }
        let remaining = JSON.parse(JSON.stringify(graphData.nodes));
        let links = JSON.parse(JSON.stringify(graphData.links));
        let currentLink = decodeURI(window.location.pathname);
        let currentNode = remaining[currentLink] || Object.values(remaining).find((v) => v.home);
        delete remaining[currentNode.url];
        if (!currentNode.home) {
            let home = Object.values(remaining).find((v) => v.home);
            delete remaining[home.url];
        }
        currentNode.current = true;
        let existing = {};
        existing[currentNode.url] = currentNode;
        for (let i = 0; i < depth; i++) {
            existing, remaining = getNextLevelNeighbours(existing, remaining);
        }
        nodes = Object.values(existing);
        if (!currentNode.home) {
            nodes = nodes.filter(n => !n.home);
        }
        let ids = nodes.map((n) => n.id);
        return {
            nodes,
            links: links.filter(function (con) {
                return ids.indexOf(con.target) > -1 && ids.indexOf(con.source) > -1;
            }),
        }
    }

    function getCssVar(variable) {return getComputedStyle(document.body).getPropertyValue(variable)}

    // Label collision avoidance function
    function calculateLabelPosition(currentNode, allNodes, nodeRadius) {
        const minDistance = 25; // Minimum distance between labels
        const offsetDistance = 12; // How far to offset when collision detected
        
        // Default position (below node)
        let offset = { x: 0, y: 0 };
        
        // Check for nearby nodes that would cause label overlap
        const nearbyNodes = allNodes.filter(node => {
            if (node.id === currentNode.id) return false;
            
            const distance = Math.sqrt(
                Math.pow(node.x - currentNode.x, 2) + 
                Math.pow(node.y - currentNode.y, 2)
            );
            
            return distance < minDistance;
        });
        
        // If no nearby nodes, use default position
        if (nearbyNodes.length === 0) {
            return offset;
        }
        
        // Simple collision avoidance: try different positions
        const positions = [
            { x: 0, y: 0 },           // Below (default)
            { x: 0, y: -offsetDistance * 2 }, // Above  
            { x: offsetDistance, y: 0 },      // Right
            { x: -offsetDistance, y: 0 },     // Left
            { x: offsetDistance, y: -offsetDistance }, // Top-right
            { x: -offsetDistance, y: -offsetDistance }, // Top-left
            { x: offsetDistance, y: offsetDistance },   // Bottom-right
            { x: -offsetDistance, y: offsetDistance }   // Bottom-left
        ];
        
        // Find position with least conflicts
        let bestPosition = positions[0];
        let minConflicts = Infinity;
        
        for (const pos of positions) {
            let conflicts = 0;
            const labelX = currentNode.x + pos.x;
            const labelY = currentNode.y + nodeRadius + 4 + pos.y;
            
            for (const nearby of nearbyNodes) {
                const nearbyLabelY = nearby.y + nodeRadius + 4;
                const distance = Math.sqrt(
                    Math.pow(labelX - nearby.x, 2) + 
                    Math.pow(labelY - nearbyLabelY, 2)
                );
                
                if (distance < 20) { // Label conflict threshold
                    conflicts++;
                }
            }
            
            if (conflicts < minConflicts) {
                minConflicts = conflicts;
                bestPosition = pos;
            }
        }
        
        return bestPosition;
    }

    function htmlDecode(input) {
        var doc = new DOMParser().parseFromString(input, "text/html");
        return doc.documentElement.textContent;
    }

    function renderGraph(graphData, id, delay, fullScreen) {
        if (graphData == null) {
            return;
        }
        if (typeof ForceGraph === 'undefined') {
            console.warn('ForceGraph library not loaded yet');
            return;
        }
        const el = document.getElementById(id);
        width = el.offsetWidth;
        height = el.offsetHeight;
        const highlightNodes = new Set();
        let hoverNode = null;
        // Use configured colors from GRAPH_COLORS object
        let Graph = ForceGraph()
        (el)
            .graphData(graphData)
            .nodeId('id')
            .nodeLabel('title')
            .linkSource('source')
            .linkTarget('target')
            .d3AlphaDecay(0.10)
            .width(width)
            .height(height)
            .linkDirectionalArrowLength(2)
            .linkDirectionalArrowRelPos(0.5)
            .autoPauseRedraw(false)
            .linkColor((link) => {
                if (hoverNode == null) {
                    return GRAPH_COLORS.edgeActive;
                }
                if (link.source.id == hoverNode.id || link.target.id == hoverNode.id) {
                    return GRAPH_COLORS.edgeConnected;
                } else {
                    return GRAPH_COLORS.edgeFaded;
                }
                
            })
            .nodeCanvasObject((node, ctx) => {
                const numberOfNeighbours = (node.neighbors && node.neighbors.length) || 2;
                const nodeR = Math.min(7, Math.max(numberOfNeighbours / 2, 2));
                
                ctx.beginPath();
                ctx.arc(node.x, node.y, nodeR, 0, 2 * Math.PI, false);
                if (hoverNode == null) {
                    ctx.fillStyle = GRAPH_COLORS.active;
                } else {
                    if (node == hoverNode) {
                        // Hovered node gets the strongest color
                        ctx.fillStyle = GRAPH_COLORS.active;
                    } else if (highlightNodes.has(node.url)) {
                        // Connected nodes get the connected color
                        ctx.fillStyle = GRAPH_COLORS.connected;
                    } else {
                        // Unconnected nodes are very faded
                        ctx.fillStyle = GRAPH_COLORS.faded;
                    }
                }
                 
                ctx.fill();
                
                if (node.current) {
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, nodeR + 1, 0, 2 * Math.PI, false);
                    ctx.lineWidth = 0.5;
                    ctx.strokeStyle = GRAPH_COLORS.current;
                    ctx.stroke();
                }

                // Only show labels when enlarged or fullscreen (not minimized)  
                if (fullScreen) {
                    // Determine if this label should be shown
                    let showLabel = true;
                    if (hoverNode != null) {
                        // When hovering, only show labels for hovered and connected nodes
                        showLabel = (node == hoverNode || highlightNodes.has(node.url));
                    }
                    
                    if (showLabel) {
                        const label = htmlDecode(node.title);
                        const fontSize = 3.5;
                        ctx.font = `${fontSize}px Sans-Serif`;
                        
                        // Calculate label position with collision avoidance
                        const labelOffset = calculateLabelPosition(node, graphData.nodes, nodeR);
                        
                        // Draw label text - full opacity for visible labels
                        ctx.fillStyle = '#57120D'; // Full color since we're only showing relevant labels
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'top';
                        ctx.fillText(label, node.x + labelOffset.x, node.y + nodeR + 4 + labelOffset.y);
                    }
                }
            })
            .onNodeClick(node => {
                window.location = node.url;
            })
            .onNodeHover(node => {
                highlightNodes.clear();
                if (node) {
                highlightNodes.add(node);
                node.neighbors.forEach(neighbor => highlightNodes.add(neighbor));
                }
                hoverNode = node || null;
                
            });
            
            if (fullScreen || (delay != null && graphData.nodes.length > 1)) {
                setTimeout(() => {
                    Graph.zoomToFit(5, 75);
                }, delay || 200);
            }
        return Graph;
    }

    // Shared helper: dispose current graph then render new data into same canvas
    function swapGraph(data, viewMode){
        if(window.graph && window.graph._destructor){
            window.graph._destructor();
        }
        const isFullscreen = viewMode === 'fullscreen';
        const enlarged = viewMode === 'enlarged' || isFullscreen;
        const delay = enlarged ? 200 : null; // auto-fit when enlarged/fullscreen
        return renderGraph(data, 'link-graph', delay, enlarged);
    }

    function renderLocalGraph(graphData, depth, viewMode) {
        const data = filterLocalGraphData(graphData, depth);
        return swapGraph(data, viewMode);
    }

    function filterFullGraphData(graphData) {
        if (graphData == null) {
            return null;
        }
        graphData = JSON.parse(JSON.stringify(graphData));
        const hiddens = Object.values(graphData.nodes).filter((n) => n.hide).map((n) => n.id);
        const data = {
            links: JSON.parse(JSON.stringify(graphData.links)).filter((l) => hiddens.indexOf(l.source) == -1 && hiddens.indexOf(l.target) == -1),
            nodes: [...Object.values(graphData.nodes).filter((n) => !n.hide)]
        }
        return data
    }

    function renderGlobalGraph(fullGraphData, viewMode) {
        return swapGraph(fullGraphData, viewMode);
    }

    // Expose helpers for Alpine expressions
    window.renderLocalGraph = renderLocalGraph;
    window.renderGlobalGraph = renderGlobalGraph;

</script>
<div  x-init="{graphData, fullGraphData} = await fetchGraphData();" x-data="{ graphData: null, fullGraphData: null, depth: 1, savedDepth: 1, showingGlobal: false, viewMode: 'minimized', graph: null }" x-effect="document.body.classList.toggle('graph-fullscreen-active', viewMode === 'fullscreen')" id="graph-component" x-bind:class="viewMode === 'enlarged' ? 'graph graph-fs' : viewMode === 'fullscreen' ? 'graph graph-fullscreen' : 'graph'" v-scope>
    <div class="graph-title-container">
        <div class="graph-title">Knowledge Graph</div>
    </div>
    <div id="link-graph" x-effect="window.graph = showingGlobal ? renderGlobalGraph(fullGraphData, viewMode) : renderLocalGraph(graphData, depth, viewMode)"></div>
    <div id="graph-controls">
            <div class="depth-control">
                <label for="graph-depth">Depth</label>
                <div class="simple-slider">
                    <input x-model.number="depth" type="range" min="1" max="3" step="1" id="graph-depth">
                </div>
                <span id="depth-display" x-text="depth"></span>
            </div>
            <div class="ctrl-right">
                <div class="button-container">
                    <span id="global-graph-btn"
                          x-on:click="
                             if(!showingGlobal){
                                 savedDepth = depth;
                                 showingGlobal = true;
                                 document.getElementById('graph-depth').disabled = true;
                                 
                              } else {
                                 depth = savedDepth;
                                 showingGlobal = false;
                                 document.getElementById('graph-depth').disabled = false;
                              }
                          "
                          :title="showingGlobal ? 'Return to page graph' : 'Show global graph'">
                          <i icon-name="globe" x-show="!showingGlobal" aria-hidden="true"></i>
                          <i icon-name="file-check" x-show="showingGlobal" aria-hidden="true"></i>
                    </span>
                    <span x-show="viewMode === 'minimized'" id="graph-enlarge-btn" x-on:click="viewMode = 'enlarged'" title="Enlarge graph"><i icon-name="expand" aria-hidden="true"></i></span>
                    <span x-show="viewMode === 'enlarged'" id="graph-fullscreen-btn" x-on:click="viewMode = 'fullscreen'" title="Enter fullscreen"><i icon-name="maximize-2" aria-hidden="true"></i></span>
                    <span x-show="viewMode === 'enlarged'" id="graph-minimize-btn" x-on:click="viewMode = 'minimized'" title="Minimize graph"><i icon-name="minimize-2" aria-hidden="true"></i></span>
                    <span x-show="viewMode === 'fullscreen'" id="graph-close-btn" x-on:click="viewMode = 'minimized'" title="Exit fullscreen"><i icon-name="x" aria-hidden="true"></i></span>
                </div>
            </div>
    </div>
    <!-- Modal removed: global graph now swaps inline -->
</div>
