<script>
    async function fetchGraphData() {
        const graphData = await fetch('/graph.json').then(res => res.json());
        const fullGraphData  = filterFullGraphData(graphData);
        return {graphData, fullGraphData}
    }

    function getNextLevelNeighbours(existing, remaining) {
        const keys = Object.values(existing).map((n) => n.neighbors).flat();
        const n_remaining = Object.keys(remaining).reduce((acc, key) => {
                if (keys.indexOf(key) != -1) {
                    if (!remaining[key].hide) {
                        existing[key] = remaining[key];
                    }
                } else {
                    acc[key] = remaining[key];
                }
                return acc;
            }, {});
        return existing, n_remaining;
    }

    function filterLocalGraphData(graphData, depth) {
        if (graphData == null) {
            return null;
        }
        let remaining = JSON.parse(JSON.stringify(graphData.nodes));
        let links = JSON.parse(JSON.stringify(graphData.links));
        let currentLink = decodeURI(window.location.pathname);
        let currentNode = remaining[currentLink] || Object.values(remaining).find((v) => v.home);
        delete remaining[currentNode.url];
        if (!currentNode.home) {
            let home = Object.values(remaining).find((v) => v.home);
            delete remaining[home.url];
        }
        currentNode.current = true;
        let existing = {};
        existing[currentNode.url] = currentNode;
        for (let i = 0; i < depth; i++) {
            existing, remaining = getNextLevelNeighbours(existing, remaining);
        }
        nodes = Object.values(existing);
        if (!currentNode.home) {
            nodes = nodes.filter(n => !n.home);
        }
        let ids = nodes.map((n) => n.id);
        return {
            nodes,
            links: links.filter(function (con) {
                return ids.indexOf(con.target) > -1 && ids.indexOf(con.source) > -1;
            }),
        }
    }

    function getCssVar(variable) {return getComputedStyle(document.body).getPropertyValue(variable)}

    function htmlDecode(input) {
        var doc = new DOMParser().parseFromString(input, "text/html");
        return doc.documentElement.textContent;
    }

    function renderGraph(graphData, id, delay, fullScreen) {
        if (graphData == null) {
            return;
        }
        if (typeof ForceGraph === 'undefined') {
            console.warn('ForceGraph library not loaded yet');
            return;
        }
        const el = document.getElementById(id);
        width = el.offsetWidth;
        height = el.offsetHeight;
        const highlightNodes = new Set();
        let hoverNode = null;
        const color = getCssVar("--graph-main");
        const mutedColor = getCssVar("--graph-muted");
        let Graph = ForceGraph()
        (el)
            .graphData(graphData)
            .nodeId('id')
            .nodeLabel('title')
            .linkSource('source')
            .linkTarget('target')
            .d3AlphaDecay(0.10)
            .width(width)
            .height(height)
            .linkDirectionalArrowLength(2)
            .linkDirectionalArrowRelPos(0.5)
            .autoPauseRedraw(false)
            .linkColor((link) => {
                if (hoverNode == null) {
                    return color;
                }
                if (link.source.id == hoverNode.id || link.target.id == hoverNode.id) {
                    return color;
                } else {
                    return mutedColor;
                }
                
            })
            .nodeCanvasObject((node, ctx) => {
                const numberOfNeighbours = (node.neighbors && node.neighbors.length) || 2;
                const nodeR = Math.min(7, Math.max(numberOfNeighbours / 2, 2));
                
                ctx.beginPath();
                ctx.arc(node.x, node.y, nodeR, 0, 2 * Math.PI, false);
                if (hoverNode == null) {
                    ctx.fillStyle = color;
                } else {
                    if (node == hoverNode || highlightNodes.has(node.url)) {
                        ctx.fillStyle = color;
                    } else {
                        ctx.fillStyle = mutedColor;
                    }
                }
                 
                ctx.fill();
                
                if (node.current) {
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, nodeR + 1, 0, 2 * Math.PI, false);
                    ctx.lineWidth = 0.5;
                    ctx.strokeStyle = color;
                    ctx.stroke();
                }

                // Only show labels when enlarged or fullscreen (not minimized)  
                if (fullScreen) {
                    const label = htmlDecode(node.title)
                    const fontSize = 3.5;
                    ctx.font = `${fontSize}px Sans-Serif`;

                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText(label, node.x, node.y + nodeR + 2);
                }
            })
            .onNodeClick(node => {
                window.location = node.url;
            })
            .onNodeHover(node => {
                highlightNodes.clear();
                if (node) {
                highlightNodes.add(node);
                node.neighbors.forEach(neighbor => highlightNodes.add(neighbor));
                }
                hoverNode = node || null;
                
            });
            
            if (fullScreen || (delay != null && graphData.nodes.length > 1)) {
                setTimeout(() => {
                    Graph.zoomToFit(5, 75);
                }, delay || 200);
            }
        return Graph;
    }

    // Shared helper: dispose current graph then render new data into same canvas
    function swapGraph(data, viewMode){
        if(window.graph && window.graph._destructor){
            window.graph._destructor();
        }
        const isFullscreen = viewMode === 'fullscreen';
        const enlarged = viewMode === 'enlarged' || isFullscreen;
        const delay = enlarged ? 200 : null; // auto-fit when enlarged/fullscreen
        return renderGraph(data, 'link-graph', delay, enlarged);
    }

    function renderLocalGraph(graphData, depth, viewMode) {
        const data = filterLocalGraphData(graphData, depth);
        return swapGraph(data, viewMode);
    }

    function filterFullGraphData(graphData) {
        if (graphData == null) {
            return null;
        }
        graphData = JSON.parse(JSON.stringify(graphData));
        const hiddens = Object.values(graphData.nodes).filter((n) => n.hide).map((n) => n.id);
        const data = {
            links: JSON.parse(JSON.stringify(graphData.links)).filter((l) => hiddens.indexOf(l.source) == -1 && hiddens.indexOf(l.target) == -1),
            nodes: [...Object.values(graphData.nodes).filter((n) => !n.hide)]
        }
        return data
    }

    function renderGlobalGraph(fullGraphData, viewMode) {
        return swapGraph(fullGraphData, viewMode);
    }

    // Expose helpers for Alpine expressions
    window.renderLocalGraph = renderLocalGraph;
    window.renderGlobalGraph = renderGlobalGraph;

</script>
<div  x-init="{graphData, fullGraphData} = await fetchGraphData();" x-data="{ graphData: null, fullGraphData: null, depth: 1, savedDepth: 1, showingGlobal: false, viewMode: 'minimized', graph: null }" x-effect="document.body.classList.toggle('graph-fullscreen-active', viewMode === 'fullscreen')" id="graph-component" x-bind:class="viewMode === 'enlarged' ? 'graph graph-fs' : viewMode === 'fullscreen' ? 'graph graph-fullscreen' : 'graph'" v-scope>
    <div class="graph-title-container">
        <div class="graph-title">Knowledge Graph</div>
    </div>
    <div id="link-graph" x-effect="window.graph = showingGlobal ? renderGlobalGraph(fullGraphData, viewMode) : renderLocalGraph(graphData, depth, viewMode)"></div>
    <div id="graph-controls">
            <div class="depth-control">
                <label for="graph-depth">Depth</label>
                <div class="simple-slider">
                    <input x-model.number="depth" type="range" min="1" max="3" step="1" id="graph-depth">
                </div>
                <span id="depth-display" x-text="depth"></span>
            </div>
            <div class="ctrl-right">
                <div class="button-container">
                    <span id="global-graph-btn"
                          x-on:click="
                             if(!showingGlobal){
                                 savedDepth = depth;
                                 showingGlobal = true;
                                 document.getElementById('graph-depth').disabled = true;
                                 
                              } else {
                                 depth = savedDepth;
                                 showingGlobal = false;
                                 document.getElementById('graph-depth').disabled = false;
                              }
                          "
                          :title="showingGlobal ? 'Return to page graph' : 'Show global graph'">
                          <i icon-name="globe" x-show="!showingGlobal" aria-hidden="true"></i>
                          <i icon-name="file-check" x-show="showingGlobal" aria-hidden="true"></i>
                    </span>
                    <span x-show="viewMode === 'minimized'" id="graph-enlarge-btn" x-on:click="viewMode = 'enlarged'" title="Enlarge graph"><i icon-name="expand" aria-hidden="true"></i></span>
                    <span x-show="viewMode === 'enlarged'" id="graph-fullscreen-btn" x-on:click="viewMode = 'fullscreen'" title="Enter fullscreen"><i icon-name="maximize-2" aria-hidden="true"></i></span>
                    <span x-show="viewMode === 'enlarged'" id="graph-minimize-btn" x-on:click="viewMode = 'minimized'" title="Minimize graph"><i icon-name="minimize-2" aria-hidden="true"></i></span>
                    <span x-show="viewMode === 'fullscreen'" id="graph-close-btn" x-on:click="viewMode = 'minimized'" title="Exit fullscreen"><i icon-name="x" aria-hidden="true"></i></span>
                </div>
            </div>
    </div>
    <!-- Modal removed: global graph now swaps inline -->
</div>
