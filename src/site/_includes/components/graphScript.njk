<script>
    // Add custom tooltip styling
    if (!document.getElementById('graph-tooltip-styles')) {
        const style = document.createElement('style');
        style.id = 'graph-tooltip-styles';
        style.textContent = `
            /* Target all possible tooltip selectors */
            .scene-tooltip, 
            .graph-tooltip,
            [role="tooltip"],
            .force-graph-container [role="tooltip"],
            .force-graph-container .scene-tooltip {
                background: var(--background-secondary) !important;
                opacity: 0.9 !important;
                color: #57120D !important;
                font-weight: bold !important;
                border: none !important;
                border-radius: 4px !important;
                padding: 6px 10px !important;
                font-size: 12px !important;
                font-family: Sans-Serif !important;
                box-shadow: 0 2px 8px rgba(0,0,0,0.2) !important;
                z-index: 10000 !important;
                max-width: 200px !important;
                word-wrap: break-word !important;
                pointer-events: none !important;
            }
        `;
        document.head.appendChild(style);
    }

    // Graph Color Configuration - Uses CSS variables for consistency with theme
    const GRAPH_CONFIG = {
        // Choose base color source:
        colorSource: 'graph-main',  // Options: 'text-normal', 'text-accent', 'custom', 'graph-main'
        
        // Custom color (only used if colorSource is 'custom'):
        customColor: '#44CF6E',
        
        // Opacity levels for different states
        fadedOpacity: 0.05,     // Much more transparent for unconnected nodes
        connectedOpacity: 1.0,  // Full opacity for connected nodes (clear contrast)
    };

    // Simple approach - use CSS variables like main branch but with enhanced contrast
    const GRAPH_COLORS = {
        // Nodes
        active: getCssVar("--graph-main"),              // Hovered nodes - green from theme
        connected: getCssVar("--graph-main"),           // Connected nodes - same green
        faded: 'rgba(68, 207, 110, 0.08)',             // Unconnected nodes - very faded green
        current: getCssVar("--graph-main"),             // Current page indicator
        
        // Edges/Links  
        edgeActive: '#147C83',                          // Active edges - teal color
        edgeConnected: '#147C83',                       // Connected edges - same teal
        edgeFaded: 'rgba(20, 124, 131, 0.08)'          // Faded edges - very transparent teal
    };

    async function fetchGraphData() {
        const graphData = await fetch('/graph.json').then(res => res.json());
        const fullGraphData  = filterFullGraphData(graphData);
        return {graphData, fullGraphData}
    }

    function getNextLevelNeighbours(existing, remaining) {
        const keys = Object.values(existing).map((n) => n.neighbors).flat();
        const n_remaining = Object.keys(remaining).reduce((acc, key) => {
                if (keys.indexOf(key) != -1) {
                    if (!remaining[key].hide) {
                        existing[key] = remaining[key];
                    }
                } else {
                    acc[key] = remaining[key];
                }
                return acc;
            }, {});
        return existing, n_remaining;
    }

    function filterLocalGraphData(graphData, depth) {
        if (graphData == null) {
            return null;
        }
        let remaining = JSON.parse(JSON.stringify(graphData.nodes));
        let links = JSON.parse(JSON.stringify(graphData.links));
        let currentLink = decodeURI(window.location.pathname);
        let currentNode = remaining[currentLink] || Object.values(remaining).find((v) => v.home);
        delete remaining[currentNode.url];
        if (!currentNode.home) {
            let home = Object.values(remaining).find((v) => v.home);
            delete remaining[home.url];
        }
        currentNode.current = true;
        let existing = {};
        existing[currentNode.url] = currentNode;
        for (let i = 0; i < depth; i++) {
            existing, remaining = getNextLevelNeighbours(existing, remaining);
        }
        nodes = Object.values(existing);
        if (!currentNode.home) {
            nodes = nodes.filter(n => !n.home);
        }
        let ids = nodes.map((n) => n.id);
        return {
            nodes,
            links: links.filter(function (con) {
                return ids.indexOf(con.target) > -1 && ids.indexOf(con.source) > -1;
            }),
        }
    }

    function getCssVar(variable) {return getComputedStyle(document.body).getPropertyValue(variable)}


    function htmlDecode(input) {
        var doc = new DOMParser().parseFromString(input, "text/html");
        return doc.documentElement.textContent;
    }

    function renderGraph(graphData, id, delay, fullScreen) {
        if (graphData == null) {
            return;
        }
        if (typeof ForceGraph === 'undefined') {
            console.warn('ForceGraph library not loaded yet');
            return;
        }
        const el = document.getElementById(id);
        width = el.offsetWidth;
        height = el.offsetHeight;
        const highlightNodes = new Set();
        let hoverNode = null;
        // Use configured colors from GRAPH_COLORS object
        let Graph = ForceGraph()
        (el)
            .graphData(graphData)
            .nodeId('id')
            .nodeLabel(fullScreen ? '' : (node) => htmlDecode(node.title))
            .linkSource('source')
            .linkTarget('target')
            .d3AlphaDecay(0.10)
            .width(width)
            .height(height)
            .linkDirectionalArrowLength(2)
            .linkDirectionalArrowRelPos(0.5)
            .autoPauseRedraw(false)
            .linkColor((link) => {
                if (hoverNode == null) {
                    return GRAPH_COLORS.edgeActive;
                }
                if (link.source.id == hoverNode.id || link.target.id == hoverNode.id) {
                    return GRAPH_COLORS.edgeConnected;
                } else {
                    return GRAPH_COLORS.edgeFaded;
                }
                
            })
            .nodeCanvasObject((node, ctx) => {
                const numberOfNeighbours = (node.neighbors && node.neighbors.length) || 2;
                const nodeR = Math.min(7, Math.max(numberOfNeighbours / 2, 2));
                
                ctx.beginPath();
                ctx.arc(node.x, node.y, nodeR, 0, 2 * Math.PI, false);
                if (hoverNode == null) {
                    ctx.fillStyle = GRAPH_COLORS.active;
                } else {
                    if (node == hoverNode) {
                        // Hovered node gets the strongest color
                        ctx.fillStyle = GRAPH_COLORS.active;
                    } else if (highlightNodes.has(node.url)) {
                        // Connected nodes get the connected color
                        ctx.fillStyle = GRAPH_COLORS.connected;
                    } else {
                        // Unconnected nodes are very faded
                        ctx.fillStyle = GRAPH_COLORS.faded;
                    }
                }
                 
                ctx.fill();
                
                if (node.current) {
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, nodeR + 1, 0, 2 * Math.PI, false);
                    ctx.lineWidth = 0.5;
                    ctx.strokeStyle = GRAPH_COLORS.current;
                    ctx.stroke();
                }

                // Only show labels when enlarged or fullscreen (not minimized)  
                if (fullScreen) {
                    // Determine if this label should be shown
                    let showLabel = true;
                    if (hoverNode != null) {
                        // When hovering, only show labels for hovered and connected nodes
                        showLabel = (node == hoverNode || highlightNodes.has(node.url));
                    }
                    
                    if (showLabel) {
                        const label = htmlDecode(node.title);
                        // Get current zoom level and adjust font size inversely
                        const zoomLevel = Graph.zoom();
                        const baseFontSize = 10; // Increased for better readability
                        const fontSize = baseFontSize / Math.max(zoomLevel, 0.5); // Prevent division by very small numbers
                        ctx.font = `bold ${fontSize}px Sans-Serif`;
                        
                        // Max width constraint for labels (adjust for zoom level) - increased width
                        const baseMaxWidth = 100; // Increased from 60 to allow more width for titles
                        const maxWidth = baseMaxWidth / Math.max(zoomLevel, 0.5); // Scale width inversely with zoom
                        const lineHeight = fontSize * 1.2; // Line spacing
                        
                        // Split text into multiple lines based on max width
                        const words = label.split(' ');
                        const lines = [];
                        let currentLine = '';
                        
                        for (const word of words) {
                            const testLine = currentLine ? `${currentLine} ${word}` : word;
                            const testWidth = ctx.measureText(testLine).width;
                            
                            if (testWidth <= maxWidth) {
                                currentLine = testLine;
                            } else {
                                if (currentLine) {
                                    lines.push(currentLine);
                                    currentLine = word;
                                } else {
                                    // Single word is too long, break it
                                    lines.push(word);
                                }
                            }
                        }
                        if (currentLine) {
                            lines.push(currentLine);
                        }
                        
                        // Position label at bottom right of node
                        const labelX = node.x + nodeR + 2; // 2px offset from node edge
                        const labelY = node.y + nodeR - 2; // Slightly above bottom edge
                        
                        // Draw multi-line label text without background
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'bottom';
                        ctx.fillStyle = '#57120D'; // Text color
                        
                        lines.forEach((line, index) => {
                            const currentY = labelY + (index * lineHeight);
                            ctx.fillText(line, labelX, currentY);
                        });
                    }
                }
            })
            .onNodeClick(node => {
                window.location = node.url;
            })
            .onNodeHover(node => {
                highlightNodes.clear();
                if (node) {
                highlightNodes.add(node);
                node.neighbors.forEach(neighbor => highlightNodes.add(neighbor));
                }
                hoverNode = node || null;
                
            });
            
            if (fullScreen || (delay != null && graphData.nodes.length > 1)) {
                setTimeout(() => {
                    Graph.zoomToFit(5, 75);
                }, delay || 200);
            }

            // Apply custom tooltip styling for minimized mode
            if (!fullScreen) {
                // Set up a mutation observer to catch dynamically created tooltips
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        mutation.addedNodes.forEach((node) => {
                            if (node.nodeType === Node.ELEMENT_NODE) {
                                // Check if this node or its children contain tooltips
                                const tooltips = node.querySelectorAll ? 
                                    [node, ...node.querySelectorAll('*')].filter(el => 
                                        el.style && el.style.position === 'absolute' && 
                                        (el.textContent || el.getAttribute('role') === 'tooltip')
                                    ) : [];
                                
                                tooltips.forEach(tooltip => {
                                    tooltip.style.setProperty('background', 'var(--background-secondary)', 'important');
                                    tooltip.style.setProperty('color', '#57120D', 'important');
                                    tooltip.style.setProperty('font-weight', 'bold', 'important');
                                    tooltip.style.setProperty('opacity', '0.9', 'important');
                                    tooltip.style.setProperty('border-radius', '4px', 'important');
                                    tooltip.style.setProperty('padding', '6px 10px', 'important');
                                    tooltip.style.setProperty('font-size', '12px', 'important');
                                    tooltip.style.setProperty('z-index', '10000', 'important');
                                });
                            }
                        });
                    });
                });
                
                observer.observe(document.body, { childList: true, subtree: true });
                
                // Cleanup observer when graph is destroyed
                Graph._customObserver = observer;
            }

        return Graph;
    }

    // Shared helper: dispose current graph then render new data into same canvas
    function swapGraph(data, viewMode){
        if(window.graph && window.graph._destructor){
            // Clean up custom observer if it exists
            if(window.graph._customObserver){
                window.graph._customObserver.disconnect();
            }
            window.graph._destructor();
        }
        const isFullscreen = viewMode === 'fullscreen';
        const enlarged = viewMode === 'enlarged' || isFullscreen;
        const delay = enlarged ? 200 : null; // auto-fit when enlarged/fullscreen
        return renderGraph(data, 'link-graph', delay, enlarged);
    }

    function renderLocalGraph(graphData, depth, viewMode) {
        const data = filterLocalGraphData(graphData, depth);
        return swapGraph(data, viewMode);
    }

    function filterFullGraphData(graphData) {
        if (graphData == null) {
            return null;
        }
        graphData = JSON.parse(JSON.stringify(graphData));
        const hiddens = Object.values(graphData.nodes).filter((n) => n.hide).map((n) => n.id);
        const data = {
            links: JSON.parse(JSON.stringify(graphData.links)).filter((l) => hiddens.indexOf(l.source) == -1 && hiddens.indexOf(l.target) == -1),
            nodes: [...Object.values(graphData.nodes).filter((n) => !n.hide)]
        }
        return data
    }

    function renderGlobalGraph(fullGraphData, viewMode) {
        return swapGraph(fullGraphData, viewMode);
    }

    // Expose helpers for Alpine expressions
    window.renderLocalGraph = renderLocalGraph;
    window.renderGlobalGraph = renderGlobalGraph;

</script>
<div  x-init="{graphData, fullGraphData} = await fetchGraphData();" x-data="{ graphData: null, fullGraphData: null, depth: 1, savedDepth: 1, showingGlobal: false, viewMode: 'minimized', graph: null }" x-effect="document.body.classList.toggle('graph-fullscreen-active', viewMode === 'fullscreen')" id="graph-component" x-bind:class="viewMode === 'enlarged' ? 'graph graph-fs' : viewMode === 'fullscreen' ? 'graph graph-fullscreen' : 'graph'" v-scope>
    <div class="graph-title-container">
        <div class="graph-title">Knowledge Graph</div>
    </div>
    <div id="link-graph" x-effect="window.graph = showingGlobal ? renderGlobalGraph(fullGraphData, viewMode) : renderLocalGraph(graphData, depth, viewMode)"></div>
    <div id="graph-controls">
            <div class="depth-control">
                <label for="graph-depth">Depth</label>
                <div class="simple-slider">
                    <input x-model.number="depth" type="range" min="1" max="3" step="1" id="graph-depth">
                </div>
                <span id="depth-display" x-text="depth"></span>
            </div>
            <div class="ctrl-right">
                <div class="button-container">
                    <span id="global-graph-btn"
                          x-on:click="
                             if(!showingGlobal){
                                 savedDepth = depth;
                                 showingGlobal = true;
                                 document.getElementById('graph-depth').disabled = true;
                                 
                              } else {
                                 depth = savedDepth;
                                 showingGlobal = false;
                                 document.getElementById('graph-depth').disabled = false;
                              }
                          "
                          :title="showingGlobal ? 'Return to page graph' : 'Show global graph'">
                          <i icon-name="globe" x-show="!showingGlobal" aria-hidden="true"></i>
                          <i icon-name="file-check" x-show="showingGlobal" aria-hidden="true"></i>
                    </span>
                    <span x-show="viewMode === 'minimized'" id="graph-enlarge-btn" x-on:click="viewMode = 'enlarged'" title="Enlarge graph"><i icon-name="expand" aria-hidden="true"></i></span>
                    <span x-show="viewMode === 'enlarged'" id="graph-fullscreen-btn" x-on:click="viewMode = 'fullscreen'" title="Enter fullscreen"><i icon-name="maximize-2" aria-hidden="true"></i></span>
                    <span x-show="viewMode === 'enlarged'" id="graph-minimize-btn" x-on:click="viewMode = 'minimized'" title="Minimize graph"><i icon-name="minimize-2" aria-hidden="true"></i></span>
                    <span x-show="viewMode === 'fullscreen'" id="graph-close-btn" x-on:click="viewMode = 'minimized'" title="Exit fullscreen"><i icon-name="x" aria-hidden="true"></i></span>
                </div>
            </div>
    </div>
    <!-- Modal removed: global graph now swaps inline -->
</div>
